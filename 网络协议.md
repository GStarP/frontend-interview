# 网络协议

## TCP 和 UDP

- 都是传输层协议（位于应用层和网络层之间）
- TCP
  - 三次握手
    - 起初，客户端为 CLOSED 状态；服务器为 LISTEN 状态
    - 第一次：建立连接时，客户端发送 **SYN=1**（报文标志位），seq=x 包到服务器，等待服务器确认；客户端进入 SYN_SEND 状态
      - seq 是指本报文段的序号
    - 第二次：服务器收到，返回 **SYN=1，ACK=1**，seq=y，ack=x+1；服务器进入 SYN_RECV 状态
      - ack=x+1 表示确认收到第 x 个报文段
    - 第三次：客户端收到，向服务器发送 **ACK=1**，seq=x+1，ack=y+1；客户端进入 ESTABLISHED 状态
    - 服务端接收到，进入 ESTABLISHED 状态
  - 四次挥手
    - 第一次：客户端发送一个 **FIN=1**，seq=x；客户端关闭到服务端的数据传送；客户端进入 FIN_WAIT_1 状态
    - 第二次：服务端发送 **ACK=1**，seq=y，ack=x+1；服务端进入 CLOSE_WAIT 状态
    - 第三次：服务端完成全部的数据传输，向客户端发送 **FIN=1，ACK=1**，seq=z，ack=u+1；服务端进入 LAST_ACK 状态，客户端进入 FIN_WAIT_2 状态
    - 第四次：客户端收到发送 **ACK=1**，seq=x+1，ack=z+1；客户端进入 TIME_WAIT 状态，该状态持续 2MSL，若这段时间内没有收到服务端重发请求，就进入 CLOSED 状态
    - 服务端收到 ACK 包，进入 CLOSED 状态
  - 特点
    - 面向连接：传输数据前必须通过三次握手建立连接
    - 仅支持一对一通信
    - 支持全双工通信（两端可同时进行发送和接收）
    - 面向字节流：TCP 把应用层传来的报文看作无意义的字节流，仅将它们编号并存储在发送缓存中；当需要发送的时候，TCP 选取一定数量的字节，构建成 TCP 报文段并发送；接收端将字节存储在接收缓存中，并交付给应用层，应用层负责识别字节为有意义的数据
    - 可靠传输：给每个报文段一个序号，保证了按序接收；接收端对已成功收到的报文段发回一个确认；如果发送端在 合理往返时延（RTT）内未收到确认，那么对应的数据将会被重传
    - 拥塞控制：当网络出现拥塞的时候，TCP 能够减小向网络层注入数据的速率和数量，缓解拥塞
    - 首部最小 20 字节，最大 60 字节
    - 适用于要求可靠传输的应用，如文件传输
- UDP
  - 无连接：不需要建立连接，想发就发
  - 能支持一对多和多对多的传输
  - 面向报文：对于应用层传来的报文，添加首部后就向下交给 IP 层，不做合并或拆分，保留报文边界
    - 因此要求应用程序控制合理的报文大小
  - 不可靠性：不备份，也不关心对方是否收到数据
  - 无拥塞控制，一直以恒定速率发送数据，因此网络条件不好的情况下可能丢包
  - 首部开销较小，共 8 字节：2 字节源端口号 + 2 字节目标端口号 +2 字节整个报文长度 + 2 字节校验和
  - 适用于实时应用，如视频会议、直播等
- TCP/IP
  - 是一个协议集合
  - 包含了 TCP，IP，DNS，TFTP 等不同层的多种协议

## HTTP

> [HTTP 简介 | 菜鸟教程](https://www.runoob.com/http/http-intro.html)

- 超文本传输协议（HyperText Transfer Protocol） 
  - 是一个应用层协议，要求传输层协议提供可靠的传输（常用 TCP）
  - 它定义了客户端如何从服务器请求资源，服务器如何把资源响应给客户端
  - 默认端口：80
- 无连接
  - 早期：每次连接只处理一个请求，服务器处理完客户请求并得到确认后，断开连接
  - HTTP 1.1：等待几秒，如果客户端有新请求，继续使用当前连接；如果没有，断开连接
  - 好处：节省传输时间，提高并发性能
  - 可以通过 `Connection: keep-alive` 支持长连接
- 独立于媒体
  - 只要客户端和服务器知道如何处理数据，任何类型的数据都可以通过 HTTP 传输
  - 通过 **MIME Type** 指定数据类型
    - 由官方组织定义
    - application：表明是某种二进制数据
    - multipart：表示细分的文件类型，一般对应多个其它类型（比如 multipart/form 中包含文本和图像）
    - 没有特定的子类型，使用 text/plain 和 application/octet-stream
- 无状态
  - 不保存先前处理的请求/响应的信息
  - 好处：提高处理效率
  - 可以通过 Cookie 保持状态
- 请求报文格式

```
POST /home/about HTTP/1.1

Content-Type: application/json

{"name": "wyx"}
```

- 响应报文格式

```
HTTP/1.1 200 OK

Content-Type: text/html

<html><body></body></html>
```

### 方法

- 八类

  - GET：获取资源，但不产生副作用
    - 通过 URL 路径参数传递数据，因为 URL 长度有限，所以数据量有限
  - HEAD：获取资源元信息
  - POST：创建或修改资源
  - PUT：更新资源
  - DELETE：删除资源
  - OPTIONS：获取该资源支持的所有方法（用 * 代替资源名称可以测试服务器是否正常运作）
  - TRACE：回显服务器收到的请求，用于调试
  - CONNECT
- 必须实现 GET 和 HEAD
- 区分大小写
- 资源不支持方法应返回 405，服务器不支持方法应返回 501

### 状态码

- 1：信息，服务器收到请求，需要请求者继续操作
  - 100：客户端应继续其请求
  - 101：服务端根据客户端的要求切换协议（只能切换到更高）
- 2：请求被成功接收并处理
  - 200（OK）：请求成功
  - 202（Accepted）：已接受请求，但未完成处理
- 3：重定向
  - 301（Moved Permanently）：永久移动，请求资源已移动到新的 URI，自动重定向到新 URI，今后任何请求都应该以新的 URI 代替
  - 302（Found）：暂时移动，资源只是临时移动，客户端此后应继续使用原本的 URL
  - 304（Not Modified）：未修改，所请求的资源未修改（详见浏览器缓存相关）
  - 305（Use Proxy）：使用代理，所请求的资源必须通过代理访问
- 4：客户端错误
  - 400（Bad Request）：请求语法错误，服务器无法理解
    - 请求的字段名称与后端定义的不一致
  - 401（Unauthorized）：要求用户进行身份认证
  - 403（Forbidden）：服务器理解客户端请求，但拒绝执行
    - 没有访问资源的权限；反爬机制
  - 404（Not Found）：服务器无法根据请求找到相应的资源
  - 405（Method Not Allowed）：资源不支持对应方法
  - 429（Too Many Requests）：限制客户端请求服务的数量，会返回延时 Refer-After
- 5：服务器错误
  - 500（Internal Error）：服务器内部错误
  - 501（Not Implemented）：服务器不支持请求的功能
  - 502（Bad Gateway）：作为网关或代理工作的服务器尝试执行请求时，从远程服务器收到了一个无效响应
  - 503（Service Unavailable）：由于超载或系统维护，服务器暂时无法处理客户端请求；会返回延时 Refer-After
  - 504（Gateway Time-out）：充当网关或代理的服务器，未及时从远端服务器获取响应
    - 负载很大（抢票）；延迟过高
  - 505（HTTP Version not supported）：服务器不支持当前版本的 HTTP 请求

## HTTP Header

### Content-Type

- 表示请求中的数据类型
- 值为 MIME Type

## DNS

- 域名 $\rightarrow$ IP 地址
- 应用层协议
- 域名服务器
  - 根 DNS：最高层级，全世界共 13 台，管理所有顶级域名
  - 顶级 DNS：管理自己负责的二级域名
  - 二级 DNS：管理下属的三级域名
  - ……
- 过程
  - 客户端就域名 A 查找本地 hosts 文件
  - 若无记录，向本地 DNS 服务器发出查询请求
  - 本地 DNS 查找本地缓存，若存在则把 IP 返回给客户端
  - 若不存在，本地 DNS 向根 DNS 发出查询请求，得到下一步应该请求的顶级 DNS 的 IP 地址
  - 本地 DNS 向此顶级 DNS 发出查询请求，得到下一个层级的 DNS 地址
  - 迭代直至本地 DNS 得到域名 A 的 IP 地址，存入缓存，并返回给客户端

## HTTPS

- HTTP + SSL/TSL
- 为什么需要？
  - HTTP 没有身份认证的过程，且数据全部明文传输
  - 黑客可以获知并修改内容、伪装服务端（劫持）
  - 所以，数据需要加密！
- 加密方式
  - 对称加密：双方持有相同的秘钥
    - 优点：计算速度快
    - 问题：怎样安全地交换秘钥
  - 非对称加密：A 的公钥和算法公开，B 使用自己的私钥解密 A 发给 B 的数据
    - 优点：安全性满足要求
    - 问题：计算速度过慢
  - 综合
    - 于是我们想到，可以通过非对称加密交换对称加密秘钥，然后再使用对称加密通信
- SSL 证书
  - 用于确认服务器的身份
  - 包含：证书的颁发机构 CA，证书有效期，公钥，签名……
- 交换过程
  - 浏览器将自己支持的加密规则发送给服务器
  - 服务器选择一组加密算法和 Hash 算法，并将公钥（通过 RSA 生成公钥私钥）放在证书中发给浏览器
  - 浏览器校验证书格式，校验有效期等信息
  - 浏览器查找 CA 是否为内置的合法机构（非常稳定，会内置在操作系统中）
  - 若查找成功，取 CA 的公钥解密签名
    - 签名 = 数据 + Hash(数据)
  - 计算签名中数据的哈希值，与签名的哈希部分比对，检验数据是否被修改
  - 若检验正确，则身份确认成功，浏览器读取公钥
  - 浏览器生成一个随机数作为通信的秘钥，用公钥加密后发送至服务器
  - 服务器用私钥解密，得到秘钥，交换完成

## HTTP/2

- 二进制分帧
  - 帧：HTTP/2 的最小传输单位
  - 消息：请求、响应等，由一个或多个帧组成
  - 流：存在于连接中的一个虚拟通道，可以承载双向消息
    - 消息可以被分解为互不依赖的帧乱序发送，然后按照首部标识重新组装
  - 二进制编码
    - HTTP 采用文本格式传输数据
    - HTTP/2 采用二进制编码，传输更少，解析更快
- 多路复用
  - HTTP 的解决方法是开多个 TCP 连接
    - 但对单个域名，有 6-8 个的连接上限
  - HTTP/2 的解决方法是流并行
    - 单个域名只需要单个 TCP 连接
    - 单个连接可以承载任意数量的流，可以关闭某个流而不关闭连接
- 服务端推送
  - 在返回 HTML 时主动推送其它资源
  - 如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收
- 首部压缩
  - HTTP 每次请求会携带大量冗余的首部信息
  - HTTP/2 采用专门的压缩格式 HPACK
  - HTTP/2 在客户端和服务端都维护一个首部表，请求时只需要发送改变的部分

## WebSocket

- 怎样做到服务端数据更新时通知客户端？
  - 客户端轮询：不停向服务端发请求
    - 大量的请求只得到不变的数据，浪费带宽
  - 长轮询：客户端依然轮询，但服务端并不立即响应，而是等到有更新时再响应
    - 假如服务端数据更新速度很快，但是一定要等请求过来才能发回数据，所以最快间隔为 2 倍的 RTT（往返时间）
    - HTTP 数据包首部很大，但真正的数据其实很小，浪费带宽
  - 所以我们需要 WebSocket
- WebSocket 协议
  - 应用层协议，基于 TCP
  - 依赖 HTTP 进行一次握手（Connection: Upgrade 或 Upgrade: WebSocket）
  - 最小单位是帧，多个帧组成消息
  - 协议首部较小
  - 默认端口：80，443
- 使用场景
  - 聊天；协作编辑；实况更新
- 与 Socket 区别
  - Socket 不是一个协议，他是应用层与 TCP/IP 的一个接口
  - 把复杂的 TCP/IP 协议族隐藏在接口之后，Socket 来组织数据以符合指定协议
