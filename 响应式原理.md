# 响应式原理

## Vue3

### 简介

#### 对比 Vue2

Vue2 中基于 Object.defineProperty()，而 Vue3 中基于 Proxy，有以下两点优势

1. 可以监听属性的增删
2. 可以监听数组项的变化以及数组长度的变化

#### 基本原理

> [Vue3响应式原理及实现](https://segmentfault.com/a/1190000022871354)

- reactive(target)：将对象变为响应式
- effect(fn)：将 fn 包装成响应式函数
- track：收集依赖，为 Dep 添加 effect
- trigger：触发依赖，遍历 Dep 执行所有 effect
- handler：拦截 get，set 等操作，实现自动收集触发依赖

### 源码注解

> [Vue3响应式源码解析-reactive篇](https://juejin.cn/post/6844903969894973448#heading-2)
>
> [Vue3响应式源码解析-effect篇](https://juejin.cn/post/6844903977599893517)

#### reactive

- `reactive()` 是暴露给用户的接口，真正执行的是 `createReactiveObject()`

```typescript
function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>,
  proxyMap: WeakMap<Target, any>
) {
  // 不是对象，不做代理
  if (!isObject(target)) {
    return target
  }
  // 已经是代理对象
  if (
    target[ReactiveFlags.RAW] &&
    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
  ) {
    return target
  }
  // 已经做过代理
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 只有符合以下三个条件才能被代理
  // 1. !target[ReactiveFlags.SKIP]
  // 2. Object.isExtensible(target)
  // 3. 属于 Object/Array/Set/Map/WeakSet/WeakMap
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) {
    return target
  }
  // Object 和 Array 用 baseHandlers
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
}
```

#### handler

通过 `proxy = reactive(target)` 我们得到了一个代理对象，代理对象分为四种：

- 完全响应：嵌套的对象都是代理对象
- 只读的完全响应
- 浅层响应：只有第一层的属性是响应式的
- 只读的浅层响应

对应这四种代理对象，有四组不同的 handler，但大致思路相同，这里以默认的完全响应为例

handlers 对五种操作进行拦截，在操作时进行依赖的收集和触发：

- 收集依赖
  - get
  - has
  - ownKeys
    - Object.getOwnPropertyNames()
    - Object.getOwnPropertySymbols()
    - Object.keys()
    - Reflect.ownKeys()
- 触发依赖
  - set
  - deleteProperty

##### get

```typescript
// 标识此为纯函数，不会有副作用，方便 tree-shaking
const get = /*#__PURE__*/ createGetter()

function createGetter(isReadonly = false, shallow = false) {
  // receiver 是代理对象
  return function get(target: object, key: string | symbol, receiver: object) {
    /* 访问 __v_readonly/__v_reactive/__v_raw，略 */
   
    // 如果 target 是数组且 key 属于 includes/indexOf/lastIndexOf，要改变这些方法的行为，在其中对数组的每个值进行依赖收集
    const targetIsArray = isArray(target)
    
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
      
    // 通过 Reflect.get 一定能拿到默认行为的结果
    const res = Reflect.get(target, key, receiver)

    // 如果 key 是 Symbol 的内置方法，或者访问的是 __proto__/__v_isRef/__isVue，不收集依赖
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res
    }

    // 只读对象不收集依赖
    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }
    
    // 浅层响应不递归调用 reactive()
    if (shallow) {
      return res
    }

    // 如果是 ref 对象，说明已经收集过依赖，直接返回 ref.value，数组下标访问除外
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)
      return shouldUnwrap ? res.value : res
    }
      
    // Proxy 只能代理一层，所以如果 target[key] 是对象，就递归进行代理
    // TODO：这一步也是避免循环依赖的关键
    if (isObject(res)) {
      return isReadonly ? readonly(res) : reactive(res)
    }

    return res
  }
}
```

##### set

```typescript
const set = /*#__PURE__*/ createSetter()

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    const oldValue = (target as any)[key]
    if (!shallow) {
      value = toRaw(value)
      oldValue = toRaw(oldValue)
      // 如果旧值是 ref，但新值不是，将新值赋给 ref.value
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value
        return true
      }
    } else {
      // in shallow mode, objects are set as-is regardless of reactive or not
    }

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    // 如果 target 是原型链上的东西，不触发依赖
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        // 如果 target 没有 key 这个属性，就代表新增了属性，需要触发依赖
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {
        // 如果新旧值不相等，触发依赖
        // 为什么会有新旧值相等的情况？比如：调用 Array.push()
        // 第一次 set 是加入新的值，正常处罚依赖
        // 第二次 set 是 length 变化，这次不需要再触发依赖
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    return result
  }
}
```

##### deleteProperty

```typescript
function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  // 如果有这个 key 且删除成功就触发依赖
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}
```

##### has

```typescript
function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  track(target, TrackOpTypes.HAS, key)
  return result
}
```

##### ownKeys

```typescript
function ownKeys(target: object): (string | number | symbol)[] {
  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)
  return Reflect.ownKeys(target)
}
```

#### effect

> 后面的部分太复杂了，还没整明白，源码先不搞了
