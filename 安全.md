# Web 安全

## CSRF

- 跨站点请求伪造：Cross-Site Request Forgery
- 原理
  - 用户访问正常网站 A，输入自己的用户名和密码
  - 网站 A 返回 cookie 等信息凭据给浏览器
  - 用户在网站 A 的信息凭据未过期前又访问恶意网站 B
  - 恶意网站 B 返回 js 代码，请求网站 A
    - 此时，信息凭据被携带，网站 A 并不知道这次请求其实是由 B 发起，依然按照用户的身份处理
- 实现
  - GET：通过 img 标签的 src 属性
  - POST：通过表单，并用 js 进行自动提交
- 防范
  - 验证 Refer 值
    - 依赖浏览器的安全措施，也可能被篡改
    - 有些用户为了隐私不愿意发送请求时携带 Refer，会被误判为攻击
  - token
    - 用户访问表单页时随机生成一个 token，让表单提交时带上这个 token
  - Same Site Cookie
    - 目前只有 Chrome 支持
    - 只有当前网页的 URL 与请求一致才会携带 cookie

## XSS

- 原理：不再多讲
- 防范
  - 限制输入：只允许输入英文字母、数字、指定特殊字符
  - 转义字符
    - 将 < 转义为 &lt；将 \ 转义成 \\\
  - Http-Only
    - 对 cookie 设置 HttpOnly，这样就无法通过 document.cookie 获取

## Session 机制

- 当服务端需要为请求创建一个 session 时，首先检查请求中是否携带 session id
  - 若包含且能检索到，使用对应的 session
  - 否则，创建一个新 session 并生成一个 session id，返回给客户端
- 保存 session id 一般使用 cookie
- 但 cookie 有时候会被认为禁止，这个时候可以使用一种叫做 **URL 重写** 的古老技术
  - 将请求的基路径修改为 http://xxx.com;jsessionid=Bkg2X6Hna8
- 或在表单里偷偷藏一个 <input type="hidden" name="jsessionid" value="Bkg2X6Hna8">
- 误解：关闭浏览器 session 就会消失
  - 除非客户端请求服务端关闭 session（登出），否则服务端不会轻易删除 session
    - 因此，服务端必须为 session 设置过期时间
  - 造成误解的原因是因为一般都使用会话 cookie 来保存 sessionid，它在浏览器关闭后就消失了

## OAuth

> [阮一峰的博客](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)

- 简介
  - 数据所有者告诉系统，允许第三方应用进入系统获取数据
  - 系统产生一个令牌，代替密码，供第三方应用使用
- 令牌与密码
  - 令牌是短期的，到期自动失效；密码长期有效，如果用户不修改就不变
  - 令牌如果被数据所有者撤销，会立即失效；密码一般不允许被他人撤销
  - 令牌有权限范围，比如只读令牌；密码一般是完整权限
- 获得令牌
  - 授权码
    - 最常用，安全性最高，适用于有后端的 Web 应用
    - 过程
      - A 网站提供链接跳转至 B 网站 `b.com/oauth?redirect_uri=callback`
      - 用户在 B 网站登录并确认授权 A 网站获取数据
      - B 网站跳回 callbackUrl 并附带一个授权码 `a.com/callback?code=AUTHORIZATION_CODE`
      - A 网站后端通过授权码向 B 网站请求获取令牌
  - 隐藏式
    - 纯前端应用；安全性较低，只在 session 期间有效
    - 过程
      - A 网站提供一个链接跳转至 B 网站 `b.com/oauth?redirect_uri=callback`
      - 用户在 B 网站登录并确认授权 A 网站获取数据
      - B 网站跳回 callbackUrl 并附带令牌 `a.com/callback#token=ACCESS_TOKEN`
        - 浏览器跳转时，锚点信息不会被发送到服务器，因此能避免中间人攻击的危险
  - 密码式
    - 需要用户给出用户名和密码，风险较大
    - 过程
      - A 网站要求用户提供 B 网站的用户名和密码，通过其直接向 B 请求令牌
      - B 网站验证通过后，直接通过这个请求返回包含令牌信息的 JSON 数据
  - 凭证式
    - 适用于没有前端的命令行
    - 过程
      - A 应用向 B 发出请求，通过 client_id 和 client_secret 表明身份
        - **这里的 client_id 和 client_secret 前面几种方式也都要发，是 A 向 B 备案注册后得到的**
      - B 网站验证通过后，直接返回令牌
- 使用令牌
  - 请求头加 Authorization=ACCESS_TOKEN
- 更新令牌
  - 如果每次令牌有效期到了都要重走一遍上面的流程，有些繁琐
  - 过程
    - B 网站颁发令牌时，同时给一个 REFRESH_TOKEN
    - 在 REFRESH_TOKEN 到期之前，可以使用其向 B 请求颁发新的令牌

